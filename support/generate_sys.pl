#!/usr/bin/env perl
use strict;
use File::Temp 'tempfile';

my $preamble = qq {
/* generated by generate_sys.pl */

#![allow(non_camel_case_types)]

extern crate libc;
extern crate openssl;

/**
 * Initialize library.
 */
pub fn init() {
    openssl::init();
}

};

my $CFLAGS = $ENV{CFLAGS} || "";

(my $wrapper_fh, my $wrapper_filename) = tempfile(UNLINK => 1, SUFFIX => ".h");
print $wrapper_fh "#include <unbound.h>\n";
close $wrapper_fh;

# Used servo's bindgen: https://github.com/servo/rust-bindgen
(my $bind_cmd = qq {
    bindgen \
    --no-unstable-rust \
    --ctypes-prefix ::libc \
    --generate functions,types \
    $wrapper_filename \
    -- $CFLAGS
}) =~ s/[\n ]+/ /gm;

my $bindings = `$bind_cmd`;
die "bindgen failed - invoked as: $bind_cmd" unless $? eq 0;

my $ub_callback_expect = qq /
pub type ub_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void,
                                               arg2: ::libc::c_int,
                                               arg3: *mut ub_result)>;
/;
my $ub_callback_replace = qq /
pub type ub_callback_t = unsafe extern "C" fn(arg1: *mut ::libc::c_void,
                                              arg2: ::libc::c_int,
                                              arg3: *mut ub_result);
/;

if (index($bindings, $ub_callback_expect) == -1) {
    die "ub_callback output has changed - bindings:\n$bindings";
}

$ub_callback_expect = quotemeta $ub_callback_expect;
$bindings =~ s/$ub_callback_expect/$ub_callback_replace/g;

my $ub_ctx_expect = qq {
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ub_ctx {
    pub _address: u8,
}
impl Clone for ub_ctx {
    fn clone(&self) -> Self { *self }
}
};
my $ub_ctx_replace = "\npub enum ub_ctx{}\n";

if (index($bindings, $ub_ctx_expect) == -1) {
    die "ub_ctx output has changed - bindings:\n$bindings";
}

$ub_ctx_expect = quotemeta $ub_ctx_expect;
$bindings =~ s/$ub_ctx_expect/$ub_ctx_replace/g;

my $derive_expect = "\n#[derive(Debug, Copy)]\n";
my $derive_replace = "\n#[derive(Debug)]\n";

if (index($bindings, $derive_expect) == -1) {
    die "derive output has changed - bindings:\n$bindings";
}

$derive_expect = quotemeta $derive_expect;
$bindings =~ s/$derive_expect/$derive_replace/g;

$bindings =~ s/impl Clone for.*?}\n}\n//gs;
if (index($bindings, "Clone") != -1) {
    die "clone removal failed - bindings:\n$bindings";
}

foreach my $s ("ub_ctx_add_ta_autr", "ub_ctx_set_stub") {
    my $expect = "pub fn $s";
    my $replace = "#[cfg($s)] pub fn $s";
    if (index($bindings, $expect) == -1) {
        die "binding for $s not found - bindings:\n$bindings";
    }
    $bindings =~ s/$expect/$replace/;
}

$bindings =~ s/\@param ([a-z_]+):/\n *  * \`$1\`:/g;
$bindings =~ s/\@return/\n *  * `return`: /g;

$bindings =~ s/( \* It is called with)\n/$1:\n/g;
$bindings =~ s/ \* (void .*)/ *\n * \`$1\`\n */;
$bindings =~ s/ \*\t((?:void\*|int|struct) [a-z_]+)/ *\n *  \`$1\`/g;

my $resolve_doc_expect = qq /
 *  * `callback`: this is called on completion of the resolution.
 * 	It is called as:
 * 	void callback(void* mydata, int err, struct ub_result* result)
 * 	with mydata: the same as passed here, you may pass NULL,
 * 	with err: is 0 when a result has been found.
 * 	with result: a newly allocated result structure.
 *		The result may be NULL, in that case err is set.
/;
my $resolve_doc_replace = qq /
 *  * `callback`: this is called on completion of the resolution.
 *  It is called as:
 *
 *  `void callback(void* mydata, int err, struct ub_result* result)`
 *   * `mydata`: the same as passed here, you may pass NULL,
 *   * `err`: is 0 when a result has been found.
 *   * `result`: a newly allocated result structure.
 *
 *  The result may be NULL, in that case err is set.
/;

if (index($bindings, $resolve_doc_expect) == -1) {
    die "resolve doc output has changed - bindings:\n$bindings";
}

$resolve_doc_expect = quotemeta $resolve_doc_expect;
$bindings =~ s/$resolve_doc_expect/$resolve_doc_replace/g;

print $preamble, $bindings;
