#!/usr/bin/env perl
use strict;
use File::Temp 'tempfile';

my @default_fn = (
    'ub_ctx_create',
    'ub_ctx_delete',
    'ub_ctx_set_option',
    'ub_ctx_get_option',
    'ub_ctx_config',
    'ub_ctx_set_fwd',
    'ub_ctx_resolvconf',
    'ub_ctx_hosts',
    'ub_ctx_add_ta',
    'ub_ctx_add_ta_autr',
    'ub_ctx_add_ta_file',
    'ub_ctx_trustedkeys',
    'ub_ctx_async',
    'ub_poll',
    'ub_wait',
    'ub_fd',
    'ub_process',
    'ub_resolve',
    'ub_resolve_async',
    'ub_cancel',
    'ub_resolve_free',
    'ub_strerror',
    'ub_ctx_zone_add',
    'ub_ctx_zone_remove',
    'ub_ctx_data_add',
    'ub_ctx_data_remove',
    'ub_version',
);
my @feature_fn = (
    'ub_ctx_set_stub',
    'ub_ctx_add_ta_autr',
    'ub_ctx_set_tls',
);
my $fn_whitelist = join "|", @default_fn, @feature_fn;
my $feature_fn_doc = join "\n* ", "", @feature_fn;

my $preamble = qq {
/* generated by generate_sys.pl */

#![allow(non_camel_case_types)]
#![doc="
The following functions are behind features with the same name:
$feature_fn_doc
"]

extern crate libc;
extern crate openssl;

pub fn init() {
    openssl::init();
}

};

my $CFLAGS = $ENV{CFLAGS} || "";

(my $wrapper_fh, my $wrapper_filename) = tempfile(UNLINK => 1, SUFFIX => ".h");
print $wrapper_fh "#include <unbound.h>\n";
close $wrapper_fh;

(my $bind_cmd = qq {
    bindgen \
    --ctypes-prefix ::libc \
    --generate functions,types \
    --no-doc-comments \
    --no-layout-tests \
    --no-derive-copy \
    --no-derive-debug \
    --blacklist-type ub_serverstats \
    --opaque-type ub_ctx \
    --whitelist-function "$fn_whitelist" \
    $wrapper_filename \
    -- $CFLAGS
}) =~ s/[\n ]+/ /gm;

my $bindings = `$bind_cmd`;
die "bindgen failed - invoked as: $bind_cmd" unless $? eq 0;

while ($bindings =~ /(cargo\:.*)/g) {
    print STDERR $1, "\n";
}
$bindings =~ s/cargo:warning=.*//g;
$bindings =~ s/::std::option::Option<\s*unsafe extern "C" fn([^>]*),\s*>/unsafe extern "C" fn$1/g;

my $ub_ctx_expect = qq {
#[repr(C)]
pub struct ub_ctx {
    _unused: [u8; 0],
}
};
my $ub_ctx_replace = "\npub enum ub_ctx{}\n";

if (index($bindings, $ub_ctx_expect) == -1) {
    die "ub_ctx output has changed - bindings:\n$bindings";
}

$ub_ctx_expect = quotemeta $ub_ctx_expect;
$bindings =~ s/$ub_ctx_expect/$ub_ctx_replace/g;

foreach my $s (@feature_fn) {
    my $expect = "pub fn $s";
    my $replace = "#[cfg(feature = \"$s\")] pub fn $s";
    if (index($bindings, $expect) == -1) {
        die "binding for $s not found - bindings:\n$bindings";
    }
    $bindings =~ s/$expect/$replace/;
}

if (index($bindings, "pub was_ratelimited") == -1) {
    die "ub_ctx missing was_ratelimited - bindings:\n$bindings";
}
$bindings =~ s/pub was_ratelimited/#[cfg(ub_ctx_has_was_ratelimited)] pub was_ratelimited/;

print $preamble, $bindings;
