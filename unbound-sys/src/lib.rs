
/* generated by generate_sys.pl */

#![allow(non_camel_case_types)]

extern crate libc;
extern crate openssl;

/**
 * Initialize library.
 */
pub fn init() {
    openssl::init();
}

/* automatically generated by rust-bindgen */

pub enum ub_ctx{}
#[repr(C)]
#[derive(Debug)]
pub struct ub_result {
    pub qname: *mut ::libc::c_schar,
    pub qtype: ::libc::c_int,
    pub qclass: ::libc::c_int,
    pub data: *mut *mut ::libc::c_schar,
    pub len: *mut ::libc::c_int,
    pub canonname: *mut ::libc::c_schar,
    pub rcode: ::libc::c_int,
    pub answer_packet: *mut ::libc::c_void,
    pub answer_len: ::libc::c_int,
    pub havedata: ::libc::c_int,
    pub nxdomain: ::libc::c_int,
    pub secure: ::libc::c_int,
    pub bogus: ::libc::c_int,
    pub why_bogus: *mut ::libc::c_schar,
    pub ttl: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_ub_result() {
    assert_eq!(::std::mem::size_of::<ub_result>() , 96usize , concat ! (
               "Size of: " , stringify ! ( ub_result ) ));
    assert_eq! (::std::mem::align_of::<ub_result>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ub_result ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . qname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( qname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . qtype as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( qtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . qclass as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( qclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . len as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . canonname as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( canonname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . rcode as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( rcode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . answer_packet as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( answer_packet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . answer_len as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( answer_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . havedata as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( havedata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . nxdomain as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( nxdomain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . secure as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( secure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . bogus as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( bogus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . why_bogus as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( why_bogus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ub_result ) ) . ttl as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ub_result ) , "::" ,
                stringify ! ( ttl ) ));
}
pub type ub_callback_t = unsafe extern "C" fn(arg1: *mut ::libc::c_void,
                                              arg2: ::libc::c_int,
                                              arg3: *mut ub_result);
extern "C" {
    pub fn ub_ctx_create() -> *mut ub_ctx;
}
extern "C" {
    pub fn ub_ctx_delete(ctx: *mut ub_ctx);
}
extern "C" {
    pub fn ub_ctx_set_option(ctx: *mut ub_ctx, opt: *const ::libc::c_schar,
                             val: *const ::libc::c_schar) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_get_option(ctx: *mut ub_ctx, opt: *const ::libc::c_schar,
                             str: *mut *mut ::libc::c_schar) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_config(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_set_fwd(ctx: *mut ub_ctx, addr: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    #[cfg(ub_ctx_set_stub)] pub fn ub_ctx_set_stub(ctx: *mut ub_ctx, zone: *const ::libc::c_schar,
                           addr: *const ::libc::c_schar,
                           isprime: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_resolvconf(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_hosts(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_add_ta(ctx: *mut ub_ctx, ta: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_add_ta_file(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    #[cfg(ub_ctx_add_ta_autr)] pub fn ub_ctx_add_ta_autr(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_trustedkeys(ctx: *mut ub_ctx, fname: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_debugout(ctx: *mut ub_ctx, out: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_debuglevel(ctx: *mut ub_ctx, d: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_async(ctx: *mut ub_ctx, dothread: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_poll(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_wait(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_fd(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_process(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_resolve(ctx: *mut ub_ctx, name: *const ::libc::c_schar,
                      rrtype: ::libc::c_int, rrclass: ::libc::c_int,
                      result: *mut *mut ub_result) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_resolve_async(ctx: *mut ub_ctx, name: *const ::libc::c_schar,
                            rrtype: ::libc::c_int, rrclass: ::libc::c_int,
                            mydata: *mut ::libc::c_void,
                            callback: ub_callback_t,
                            async_id: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_cancel(ctx: *mut ub_ctx, async_id: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_resolve_free(result: *mut ub_result);
}
extern "C" {
    pub fn ub_strerror(err: ::libc::c_int) -> *const ::libc::c_schar;
}
extern "C" {
    pub fn ub_ctx_print_local_zones(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_zone_add(ctx: *mut ub_ctx,
                           zone_name: *const ::libc::c_schar,
                           zone_type: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_zone_remove(ctx: *mut ub_ctx,
                              zone_name: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_data_add(ctx: *mut ub_ctx, data: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_ctx_data_remove(ctx: *mut ub_ctx, data: *const ::libc::c_schar)
     -> ::libc::c_int;
}
extern "C" {
    pub fn ub_version() -> *const ::libc::c_schar;
}
