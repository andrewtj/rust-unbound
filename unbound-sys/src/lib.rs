
/* generated by generate_sys.pl */

#![allow(non_camel_case_types)]

extern crate libc;
extern crate openssl;

/**
 * Initialize library.
 */
pub fn init() {
    openssl::init();
}

/* automatically generated by rust-bindgen */

/**
 * The validation context is created to hold the resolver status,
 * validation keys and a small cache (containing messages, rrsets,
 * roundtrip times, trusted keys, lameness information).
 *
 * Its contents are internally defined.
 */
pub enum ub_ctx{}
/**
 * The validation and resolution results.
 * Allocated by the resolver, and need to be freed by the application
 * with ub_resolve_free().
 */
#[repr(C)]
#[derive(Debug)]
pub struct ub_result {
    /** The original question, name text string. */
    pub qname: *mut ::libc::c_char,
    /** the type asked for */
    pub qtype: ::libc::c_int,
    /** the class asked for */
    pub qclass: ::libc::c_int,
    /** 
	 * a list of network order DNS rdata items, terminated with a 
	 * NULL pointer, so that data[0] is the first result entry,
	 * data[1] the second, and the last entry is NULL. 
	 * If there was no data, data[0] is NULL.
	 */
    pub data: *mut *mut ::libc::c_char,
    /** the length in bytes of the data items, len[i] for data[i] */
    pub len: *mut ::libc::c_int,
    /** 
	 * canonical name for the result (the final cname). 
	 * zero terminated string.
	 * May be NULL if no canonical name exists.
	 */
    pub canonname: *mut ::libc::c_char,
    /**
	 * DNS RCODE for the result. May contain additional error code if
	 * there was no data due to an error. 0 (NOERROR) if okay.
	 */
    pub rcode: ::libc::c_int,
    /**
	 * The DNS answer packet. Network formatted. Can contain DNSSEC types.
	 */
    pub answer_packet: *mut ::libc::c_void,
    /** length of the answer packet in octets. */
    pub answer_len: ::libc::c_int,
    /**
	 * If there is any data, this is true.
	 * If false, there was no data (nxdomain may be true, rcode can be set).
	 */
    pub havedata: ::libc::c_int,
    /** 
	 * If there was no data, and the domain did not exist, this is true.
	 * If it is false, and there was no data, then the domain name 
	 * is purported to exist, but the requested data type is not available.
	 */
    pub nxdomain: ::libc::c_int,
    /**
	 * True, if the result is validated securely.
	 * False, if validation failed or domain queried has no security info.
	 *
	 * It is possible to get a result with no data (havedata is false),
	 * and secure is true. This means that the non-existance of the data
	 * was cryptographically proven (with signatures).
	 */
    pub secure: ::libc::c_int,
    /** 
	 * If the result was not secure (secure==0), and this result is due 
	 * to a security failure, bogus is true.
	 * This means the data has been actively tampered with, signatures
	 * failed, expected signatures were not present, timestamps on 
	 * signatures were out of date and so on.
	 *
	 * If !secure and !bogus, this can happen if the data is not secure 
	 * because security is disabled for that domain name. 
	 * This means the data is from a domain where data is not signed.
	 */
    pub bogus: ::libc::c_int,
    /**
	 * If the result is bogus this contains a string (zero terminated)
	 * that describes the failure.  There may be other errors as well
	 * as the one described, the description may not be perfectly accurate.
	 * Is NULL if the result is not bogus.
	 */
    pub why_bogus: *mut ::libc::c_char,
    /**
	 * TTL for the result, in seconds.  If the security is bogus, then
	 * you also cannot trust this value.
	 */
    pub ttl: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_ub_result() {
    assert_eq!(::std::mem::size_of::<ub_result>() , 96usize);
    assert_eq!(::std::mem::align_of::<ub_result>() , 8usize);
}
/**
 * Callback for results of async queries.
 * The readable function definition looks like:
 *
 * `void my_callback(void* my_arg, int err, struct ub_result* result);`
 *
 * It is called with:
 *
 *  `void* my_arg`: your pointer to a (struct of) data of your choice, 
 *		or NULL.
 *
 *  `int err`: if 0 all is OK, otherwise an error occured and no results
 *	     are forthcoming.
 *
 *  `struct result`: pointer to more detailed result structure.
 *		This structure is allocated on the heap and needs to be
 *		freed with ub_resolve_free(result);
 */
pub type ub_callback_t = unsafe extern "C" fn(arg1: *mut ::libc::c_void,
                                              arg2: ::libc::c_int,
                                              arg3: *mut ub_result);
extern "C" {
    /**
 * Create a resolving and validation context.
 * The information from /etc/resolv.conf and /etc/hosts is not utilised by
 * default. Use ub_ctx_resolvconf and ub_ctx_hosts to read them.
 * 
 *  * `return`:  a new context. default initialisation.
 * 	returns NULL on error.
 */
    pub fn ub_ctx_create() -> *mut ub_ctx;
}
extern "C" {
    /**
 * Destroy a validation context and free all its resources.
 * Outstanding async queries are killed and callbacks are not called for them.
 * 
 *  * `ctx`: context to delete.
 */
    pub fn ub_ctx_delete(ctx: *mut ub_ctx);
}
extern "C" {
    /**
 * Set an option for the context.
 * 
 *  * `ctx`: context.
 * 
 *  * `opt`: option name from the unbound.conf config file format.
 *	(not all settings applicable). The name includes the trailing ':'
 *	for example ub_ctx_set_option(ctx, "logfile:", "mylog.txt");
 * 	This is a power-users interface that lets you specify all sorts
 * 	of options.
 * 	For some specific options, such as adding trust anchors, special
 * 	routines exist.
 * 
 *  * `val`: value of the option.
 * 
 *  * `return`: : 0 if OK, else error.
 */
    pub fn ub_ctx_set_option(ctx: *mut ub_ctx, opt: *const ::libc::c_char,
                             val: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    /**
 * Get an option from the context.
 * 
 *  * `ctx`: context.
 * 
 *  * `opt`: option name from the unbound.conf config file format.
 *	(not all settings applicable). The name excludes the trailing ':'
 *	for example ub_ctx_get_option(ctx, "logfile", &result);
 * 	This is a power-users interface that lets you specify all sorts
 * 	of options.
 * 
 *  * `str`: the string is malloced and returned here. NULL on error.
 * 	The caller must free() the string.  In cases with multiple 
 * 	entries (auto-trust-anchor-file), a newline delimited list is 
 * 	returned in the string.
 * 
 *  * `return`:  0 if OK else an error code (malloc failure, syntax error).
 */
    pub fn ub_ctx_get_option(ctx: *mut ub_ctx, opt: *const ::libc::c_char,
                             str: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    /**
 * setup configuration for the given context.
 * 
 *  * `ctx`: context.
 * 
 *  * `fname`: unbound config file (not all settings applicable).
 * 	This is a power-users interface that lets you specify all sorts
 * 	of options.
 * 	For some specific options, such as adding trust anchors, special
 * 	routines exist.
 * 
 *  * `return`: : 0 if OK, else error.
 */
    pub fn ub_ctx_config(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Set machine to forward DNS queries to, the caching resolver to use. 
 * IP4 or IP6 address. Forwards all DNS requests to that machine, which 
 * is expected to run a recursive resolver. If the proxy is not 
 * DNSSEC-capable, validation may fail. Can be called several times, in 
 * that case the addresses are used as backup servers.
 *
 * To read the list of nameservers from /etc/resolv.conf (from DHCP or so),
 * use the call ub_ctx_resolvconf.
 *
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to set configuration before the
 *	first resolve is done.
 * 
 *  * `addr`: address, IP4 or IP6 in string format.
 * 	If the addr is NULL, forwarding is disabled.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_set_fwd(ctx: *mut ub_ctx, addr: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add a stub zone, with given address to send to.  This is for custom
 * root hints or pointing to a local authoritative dns server.
 * For dns resolvers and the 'DHCP DNS' ip address, use ub_ctx_set_fwd.
 * This is similar to a stub-zone entry in unbound.conf.
 *
 * 
 *  * `ctx`: context.
 *	It is only possible to set configuration before the
 *	first resolve is done.
 * 
 *  * `zone`: name of the zone, string.
 * 
 *  * `addr`: address, IP4 or IP6 in string format.
 * 	The addr is added to the list of stub-addresses if the entry exists.
 * 	If the addr is NULL the stub entry is removed.
 * 
 *  * `isprime`: set to true to set stub-prime to yes for the stub.
 * 	For local authoritative servers, people usually set it to false,
 * 	For root hints it should be set to true.
 * 
 *  * `return`:  0 if OK, else error.
 */
    #[cfg(ub_ctx_set_stub)] pub fn ub_ctx_set_stub(ctx: *mut ub_ctx, zone: *const ::libc::c_char,
                           addr: *const ::libc::c_char,
                           isprime: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    /**
 * Read list of nameservers to use from the filename given.
 * Usually "/etc/resolv.conf". Uses those nameservers as caching proxies.
 * If they do not support DNSSEC, validation may fail.
 *
 * Only nameservers are picked up, the searchdomain, ndots and other
 * settings from resolv.conf(5) are ignored.
 *
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to set configuration before the
 *	first resolve is done.
 * 
 *  * `fname`: file name string. If NULL "/etc/resolv.conf" is used.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_resolvconf(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Read list of hosts from the filename given.
 * Usually "/etc/hosts". 
 * These addresses are not flagged as DNSSEC secure when queried for.
 *
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to set configuration before the
 *	first resolve is done.
 * 
 *  * `fname`: file name string. If NULL "/etc/hosts" is used.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_hosts(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add a trust anchor to the given context.
 * The trust anchor is a string, on one line, that holds a valid DNSKEY or
 * DS RR. 
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to add trusted keys before the
 *	first resolve is done.
 * 
 *  * `ta`: string, with zone-format RR on one line.
 * 	[domainname] [TTL optional] [type] [class optional] [rdata contents]
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_add_ta(ctx: *mut ub_ctx, ta: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add trust anchors to the given context.
 * Pass name of a file with DS and DNSKEY records (like from dig or drill).
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to add trusted keys before the
 *	first resolve is done.
 * 
 *  * `fname`: filename of file with keyfile with trust anchors.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_add_ta_file(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add trust anchor to the given context that is tracked with RFC5011
 * automated trust anchor maintenance.  The file is written to when the
 * trust anchor is changed.
 * Pass the name of a file that was output from eg. unbound-anchor,
 * or you can start it by providing a trusted DNSKEY or DS record on one
 * line in the file.
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to add trusted keys before the
 *	first resolve is done.
 * 
 *  * `fname`: filename of file with trust anchor.
 * 
 *  * `return`:  0 if OK, else error.
 */
    #[cfg(ub_ctx_add_ta_autr)] pub fn ub_ctx_add_ta_autr(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add trust anchors to the given context.
 * Pass the name of a bind-style config file with trusted-keys{}.
 * 
 *  * `ctx`: context.
 *	At this time it is only possible to add trusted keys before the
 *	first resolve is done.
 * 
 *  * `fname`: filename of file with bind-style config entries with trust
 * 	anchors.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_trustedkeys(ctx: *mut ub_ctx, fname: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Set debug output (and error output) to the specified stream.
 * Pass NULL to disable. Default is stderr.
 * 
 *  * `ctx`: context.
 * 
 *  * `out`: FILE* out file stream to log to.
 * 	Type void* to avoid stdio dependency of this header file.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_debugout(ctx: *mut ub_ctx, out: *mut ::libc::c_void)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Set debug verbosity for the context
 * Output is directed to stderr.
 * 
 *  * `ctx`: context.
 * 
 *  * `d`: debug level, 0 is off, 1 is very minimal, 2 is detailed, 
 *	and 3 is lots.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_debuglevel(ctx: *mut ub_ctx, d: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Set a context behaviour for asynchronous action.
 * 
 *  * `ctx`: context.
 * 
 *  * `dothread`: if true, enables threading and a call to resolve_async() 
 *	creates a thread to handle work in the background.
 *	If false, a process is forked to handle work in the background.
 *	Changes to this setting after async() calls have been made have 
 *	no effect (delete and re-create the context to change).
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_async(ctx: *mut ub_ctx, dothread: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Poll a context to see if it has any new results
 * Do not poll in a loop, instead extract the fd below to poll for readiness,
 * and then check, or wait using the wait routine.
 * 
 *  * `ctx`: context.
 * 
 *  * `return`: : 0 if nothing to read, or nonzero if a result is available.
 * 	If nonzero, call ctx_process() to do callbacks.
 */
    pub fn ub_poll(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    /**
 * Wait for a context to finish with results. Calls ub_process() after
 * the wait for you. After the wait, there are no more outstanding 
 * asynchronous queries.
 * 
 *  * `ctx`: context.
 * 
 *  * `return`: : 0 if OK, else error.
 */
    pub fn ub_wait(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    /**
 * Get file descriptor. Wait for it to become readable, at this point
 * answers are returned from the asynchronous validating resolver.
 * Then call the ub_process to continue processing.
 * This routine works immediately after context creation, the fd
 * does not change.
 * 
 *  * `ctx`: context.
 * 
 *  * `return`: : -1 on error, or file descriptor to use select(2) with.
 */
    pub fn ub_fd(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    /**
 * Call this routine to continue processing results from the validating
 * resolver (when the fd becomes readable).
 * Will perform necessary callbacks.
 * 
 *  * `ctx`: context
 * 
 *  * `return`: : 0 if OK, else error.
 */
    pub fn ub_process(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    /**
 * Perform resolution and validation of the target name.
 * 
 *  * `ctx`: context.
 *	The context is finalized, and can no longer accept config changes.
 * 
 *  * `name`: domain name in text format (a zero terminated text string).
 * 
 *  * `rrtype`: type of RR in host order, 1 is A (address).
 * 
 *  * `rrclass`: class of RR in host order, 1 is IN (for internet).
 * 
 *  * `result`: the result data is returned in a newly allocated result
 * 	structure. May be NULL on return, return value is set to an error 
 * 	in that case (out of memory).
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_resolve(ctx: *mut ub_ctx, name: *const ::libc::c_char,
                      rrtype: ::libc::c_int, rrclass: ::libc::c_int,
                      result: *mut *mut ub_result) -> ::libc::c_int;
}
extern "C" {
    /**
 * Perform resolution and validation of the target name.
 * Asynchronous, after a while, the callback will be called with your
 * data and the result.
 * 
 *  * `ctx`: context.
 *	If no thread or process has been created yet to perform the
 *	work in the background, it is created now.
 *	The context is finalized, and can no longer accept config changes.
 * 
 *  * `name`: domain name in text format (a string).
 * 
 *  * `rrtype`: type of RR in host order, 1 is A.
 * 
 *  * `rrclass`: class of RR in host order, 1 is IN (for internet).
 * 
 *  * `mydata`: this data is your own data (you can pass NULL),
 * 	and is passed on to the callback function.
 * 
 *  * `callback`: this is called on completion of the resolution.
 *  It is called as:
 *
 *  `void callback(void* mydata, int err, struct ub_result* result)`
 *   * `mydata`: the same as passed here, you may pass NULL,
 *   * `err`: is 0 when a result has been found.
 *   * `result`: a newly allocated result structure.
 *
 *  The result may be NULL, in that case err is set.
 *
 * 	If an error happens during processing, your callback will be called
 * 	with error set to a nonzero value (and result==NULL).
 * 
 *  * `async_id`: if you pass a non-NULL value, an identifier number is
 *	returned for the query as it is in progress. It can be used to 
 *	cancel the query.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_resolve_async(ctx: *mut ub_ctx, name: *const ::libc::c_char,
                            rrtype: ::libc::c_int, rrclass: ::libc::c_int,
                            mydata: *mut ::libc::c_void,
                            callback: ub_callback_t,
                            async_id: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    /**
 * Cancel an async query in progress.
 * Its callback will not be called.
 *
 * 
 *  * `ctx`: context.
 * 
 *  * `async_id`: which query to cancel.
 * 
 *  * `return`:  0 if OK, else error.
 * This routine can return an error if the async_id passed does not exist
 * or has already been delivered. If another thread is processing results
 * at the same time, the result may be delivered at the same time and the
 * cancel fails with an error.  Also the cancel can fail due to a system
 * error, no memory or socket failures.
 */
    pub fn ub_cancel(ctx: *mut ub_ctx, async_id: ::libc::c_int)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Free storage associated with a result structure.
 * 
 *  * `result`: to free
 */
    pub fn ub_resolve_free(result: *mut ub_result);
}
extern "C" {
    /** 
 * Convert error value to a human readable string.
 * 
 *  * `err`: error code from one of the libunbound functions.
 * 
 *  * `return`:  pointer to constant text string, zero terminated.
 */
    pub fn ub_strerror(err: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    /**
 * Debug routine.  Print the local zone information to debug output.
 * 
 *  * `ctx`: context.  Is finalized by the routine.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_print_local_zones(ctx: *mut ub_ctx) -> ::libc::c_int;
}
extern "C" {
    /**
 * Add a new zone with the zonetype to the local authority info of the 
 * library.
 * 
 *  * `ctx`: context.  Is finalized by the routine.
 * 
 *  * `zone_name`: name of the zone in text, "example.com"
 *	If it already exists, the type is updated.
 * 
 *  * `zone_type`: type of the zone (like for unbound.conf) in text.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_zone_add(ctx: *mut ub_ctx, zone_name: *const ::libc::c_char,
                           zone_type: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    /**
 * Remove zone from local authority info of the library.
 * 
 *  * `ctx`: context.  Is finalized by the routine.
 * 
 *  * `zone_name`: name of the zone in text, "example.com"
 *	If it does not exist, nothing happens.
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_zone_remove(ctx: *mut ub_ctx,
                              zone_name: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Add localdata to the library local authority info.
 * Similar to local-data config statement.
 * 
 *  * `ctx`: context.  Is finalized by the routine.
 * 
 *  * `data`: the resource record in text format, for example
 *	"www.example.com IN A 127.0.0.1"
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_data_add(ctx: *mut ub_ctx, data: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Remove localdata from the library local authority info.
 * 
 *  * `ctx`: context.  Is finalized by the routine.
 * 
 *  * `data`: the name to delete all data from, like "www.example.com".
 * 
 *  * `return`:  0 if OK, else error.
 */
    pub fn ub_ctx_data_remove(ctx: *mut ub_ctx, data: *const ::libc::c_char)
     -> ::libc::c_int;
}
extern "C" {
    /**
 * Get a version string from the libunbound implementation.
 * 
 *  * `return`:  a static constant string with the version number.
 */
    pub fn ub_version() -> *const ::libc::c_char;
}
